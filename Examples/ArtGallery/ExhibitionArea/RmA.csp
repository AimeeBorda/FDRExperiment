EventsA = {goto.EB.EA,goto.EA.Corr,goto.EA.EB,goto.Corr.EA}

Monitors4 = union(EventsD,Monitors5)
Monitors2A = union(EventsB,Monitors5)
Monitors5 = {emergency}

MonitorsA = Union({Monitors5,Monitors4, {x | x <- Monitors2A, not approachOne}})
---------------------------------------------
--		Processes for EA
---------------------------------------------
A0 = (goto!EB!EA -> A0) [] (goto!EA?_:{Corr,EB} -> A0) [] (goto!Corr!EA -> A0)
A1 = (goto!EB!EA -> A1) [] (goto!EA?_:{Corr,EB} -> A1)

---------------------------------------------
--		Behaviour for EA
---------------------------------------------
BehaviourA =  let B(n) = (n <= MaxAgentsEA & goto!Corr!EA -> B(n+1))
							[] (n > 0 & goto!EA!Corr -> B(n-1))
							[] (n > 0 & goto!EA!EB -> B(n-1))
							[] (n <= MaxAgentsEA & goto!EB!EA -> B(n+1))
				within B(0)

---------------------------------------------
--		Requirements for EA
---------------------------------------------	
Pattern4 =  
		let P(n) =  (goto?_:{EA,ED}!Corr -> if(n >= MaxAgentsEA) then adapt!n-1 -> ack-> P(n-1) else if (n > 0) then P(n-1) else P(0))
				[] (goto!Corr!EA -> if(n >= MaxAgentsEA - 1) then adapt!MaxAgentsEA -> ack -> P(MaxAgentsEA) else P(n+1))
				[] (goto!EA!EB -> P(n))  
				[] (goto!EB!EA -> P(n)) 
				[] (goto!EB!ED -> P(n))
				[] (emergency -> RUN(union(EventsA,Monitors4))) 
			
		within P(0)
Pi4 =  adapt?v  ->  if v >= MaxAgentsEA then r!1 -> ack -> Pi4 else r!0 -> ack -> Pi4

Pattern2A = let P(n) =  (goto!Corr!EA -> if(n >= MaxAgentsPair - 1) then adapt!MaxAgentsPair -> ack -> P(MaxAgentsPair) else P(n+1))
					[] (goto!EA!Corr -> if(n >= MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else if (n > 0) then P(n-1) else P(0))
					[] (goto!EB!ED   -> if(n >= MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else if (n > 0) then P(n-1) else P(0))
					[] (goto!EA!EB -> P(n))  
					[] (goto!EB!EA -> P(n)) 
					[] (emergency -> RUN(union(EventsA,Monitors2A))) 
			within P(0)
Pi2A =  adapt?v  ->  if v >= MaxAgentsPair then r!1 -> ack -> Pi2A else r!0 -> ack -> Pi2A


Pattern5A = (emergency -> adaptE -> ack -> Pattern5A) [] (goto?_: {x | goto.x <- EventsA} -> Pattern5A)
PiEmergencyA =  adaptE  ->  r!0 -> ack -> PiEmergencyA

---------------------------------------------
--		Adaptatable Processes
---------------------------------------------
SysA = 
		let 
			map = \ id @ (if id == 0 then A0
						 else if id == 1 then A1
						 else SKIP)
			StateRec = (r?id : Processes -> (map(id) /\ StateRec))
		within
			A0 /\ StateRec

---------------------------------------------
--		Composition
---------------------------------------------
RmA = let
			eventsR2A = union(EventsA,Monitors2A)
			eventsR4 = union(EventsA,Monitors4)
			eventsR5 = union(EventsA,Monitors5)


			R4 = (Pi4 [|{|adapt,ack|}|] Pattern4) \ {|adapt,ack|}
			R2A = (Pi2A [|{|adapt,ack|}|] Pattern2A) \ {|adapt,ack|}
			R5 = (PiEmergencyA [|{|adaptE,ack|}|] Pattern5A) \ {|adaptE,ack|}
			
			FirstApproach = (R4 [|inter(eventsR4,eventsR5) |] R5)  [|inter(EventsA,Union({eventsR4,eventsR5}))|] BehaviourA
			SecondApproach =  (R2A [|inter(eventsR2A,eventsR5) |] R5) [|inter(EventsA,Union({eventsR2A,eventsR5}))|] BehaviourA

			proc = (SysA[| union(EventsA, {| r |}) |] (if(approachOne) then FirstApproach else SecondApproach)) \ {| r |}
		within 
			normal(proc)